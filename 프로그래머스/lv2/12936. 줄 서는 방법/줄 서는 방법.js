// 기본적으로 순열은 n! 가지의 경우의 수를 가진다.
// 여기서 첫번째-두번째는 맨 앞자리가 1, 세번째-네번째는 맨 앞자리가 2, 다섯번째-여섯번째는 맨 앞자리가 3인 것을 알 수 있다
// 만약 앞자리가 고정되어 있다면 남은 2개의 숫자들의 순열만 필요할 것이다. 이때 남은 2개의 숫자의 2!이 2이기 때문에 2개의 주기를 갖게된다.
// 즉 (n-1)! 반복 후에 앞자리가 바뀐다.

// k는 1 자리 고정되고 n번째 수, 그 다음 자리 고정 후 n번째 수를 의미하기 때문에
// 이를 이용해서 arr에서 숫자를 뽑아내려면 인덱스로 사용되어야 한다. 그렇기에 1을 빼야 하는 것이다
// k가 5이기때문에 항상 앞자리가 3인 것을 확인할 수 있고 이는 [인덱스/(n-1)!] 로 구할 수 있다.
// 순열의 주기 단위는 factorial(n-1) 단위로 앞자리 숫자가 변경되게 된다. 그리고 문제에서 주어지는 k는 모든 순열 중에서 k번째에 위치한 순열을 의미한다.
// 즉 k-1를 factorial(n-1)이라는 주기로 나누게 되면 그 몫은 현재 주기에서의 맨 앞에 위치한 숫자의 인덱스(index)가 될 것이다.

// 맨 앞자리는 구했는데 그렇다면 그 다음은 어떻게 또 구할 수 있을까
//  위에서 하나의 숫자를 고정하고서 주기를 구했다. 이처럼 n-1,n-2,n-3,... 가장 앞에 위치하는 값을 고정하고 반복해주면 된다.

// 인덱스 값을 다음 순열을 위해 재조정
//  앞자리 숫자의 인덱스를 찾고 난후 다음 순열에서도 맨 앞자리를 찾을 수 있도록 k 값을 재조정해주어야 한다.
// 현재 k-1의 값을 똑같이 factorial(n-1) 로 나눈 나머지가 다음 k 값
// k=110 이고 주기가 24 였을때 맨 앞에 위치하게 될 숫자는 arr[109 / 24] 가 될 것이다. 이때 109 % 24 의 값은 자연스레 현재 순열에서 얼마만큼의 순번이 떨어져 있는지를 나타낸다.

// 사용한 배열의 원소를 제거
// 구한 인덱스 제거

function solution(n, k) {
    const order = [];
    const people = Array.from({length: n}, (_, i) => i + 1);
    const getFactorial = (n) => {
        if(n === 0) return 1;
        return n * getFactorial(n - 1);
    };

    let nth = k-1;
    while (people.length) {
        if (nth === 0) {
            order.push(...people);
            break;
        }
        const fac = getFactorial(people.length - 1);
        const idx = Math.floor( nth / fac);
        nth = nth % fac;

        order.push(people[idx]);
        people.splice(idx, 1);
    }
    return order;
}